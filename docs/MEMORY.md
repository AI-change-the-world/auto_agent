# 智能体记忆系统设计方案（正式版）

> 本方案用于设计一套**可介绍、可落地、可演进的智能体记忆系统**，面向具备长期运行能力的 Agent / 多 Agent 系统，重点解决：
>
> * 记忆可控注入（避免上下文爆炸）
> * 记忆可学习（用户反馈驱动优化）
> * 记忆可管理（分类、衰减、冲突处理）
> * 兼顾工程结构化与大模型语义理解

---

## 一、设计背景与问题定义

在长期运行的智能体系统中，**记忆不应等同于对话历史**。

若简单将所有历史信息拼接进上下文，将导致：

* Token 成本失控
* 关键信息被噪声淹没
* 模型行为不稳定、不可学习

因此，需要一套：

> **可分类、可筛选、可反馈更新的记忆交互机制**，
> 并将“是否使用记忆”的决策权前移到系统层，而非完全依赖大模型推理。

---

## 二、总体设计原则

1. **分层而非堆叠**：不同生命周期的记忆必须隔离管理
2. **结构化优先**：所有可被学习和优化的记忆必须结构化存储
3. **按需注入**：记忆只在“相关且必要”时进入上下文
4. **反馈闭环**：用户反馈直接作用于记忆权重与策略
5. **人机双友好**：既服务系统决策，也支持人类理解与调试

---

## 三、记忆分层设计（Memory Layers）

### 3.1 L1：短时记忆（Working / Episodic Memory）

**定位**：单次 Agent 执行过程中的上下文状态

* 内容包括：

  * 当前 Query
  * 子任务拆解结果
  * 中间决策与工具调用
* 生命周期：

  * 默认仅在一次任务内有效
  * 任务结束后被丢弃或提炼

**用途**：

* 保证 Agent 内部推理连续性
* 为长期记忆提炼提供原材料

---

### 3.2 L2：长期语义记忆（Semantic Memory，主存储）

**定位**：系统长期可复用、可学习的核心记忆层

* 存储形式：**JSON（强结构化）**
* 必须支持：

  * 分类与标签
  * 打分与权重
  * 时间衰减
  * 用户反馈更新

**推荐一级分类（示例）：**

* work：工作 / 技术 / 业务相关
* life：生活经验 / 日常事实
* preference：用户或 Agent 偏好
* emotion：态度、情感倾向
* strategy：方法论、成功/失败策略

---

### 3.3 L3：叙事与反思记忆（Narrative / Reflection Memory）

**定位**：对长期记忆的语义压缩与自我认知表达

* 存储形式：**Markdown（自然语言）**
* 来源：

  * L2 记忆的自动总结
  * 多次经验的抽象反思

**用途**：

* Prompt 注入（高语义密度）
* 人类理解与调试
* Agent 行为风格与长期一致性塑造

> 注：L3 记忆不独立决策，必须由 L2 记忆引用与约束。

---

## 四、JSON 与 Markdown 协作策略

### 4.1 JSON：记忆的“决策与索引层”

所有长期记忆必须有 JSON 主记录，用于系统层决策：

```json
{
  "memory_id": "mem_20251214_001",
  "layer": "L2",
  "category": "work",
  "subcategory": "agent_design",
  "tags": ["memory", "architecture"],
  "content": "用户倾向于使用分层记忆以控制 token 使用",
  "confidence": 0.9,
  "reward": 1,
  "source": "user_feedback",
  "created_at": "2025-12-14",
  "summary_md_ref": "reflections/mem_20251214_001.md"
}
```

JSON 负责：

* 是否命中
* 是否注入上下文
* 注入优先级判断
* 学习与权重更新

---

### 4.2 Markdown：记忆的“语义表达层”

Markdown 以自然语言形式表达记忆含义，用于模型理解与人工查看：

```markdown
# Reflection: Memory Routing Strategy

通过先判断 Query 的领域，再定向检索对应分类记忆，
可以在显著降低上下文长度的同时，保持回答稳定性与一致性。
```

Markdown 特点：

* 高语义密度
* 强可读性
* 不参与直接决策

---

## 五、记忆交互流程设计

### 5.1 Query → 记忆命中流程

**步骤说明：**

1. Query 进入系统
2. 轻量分析 Query：

   * 意图类型（询问 / 决策 / 反思）
   * 领域分类（work / life / preference / emotion）
3. 确定所需记忆层级与分类
4. 仅在相关 L2 记忆子集中检索
5. 按权重、时间衰减排序
6. Top-K 命中记忆转为文本或 Markdown 注入上下文

> 该流程避免“全量记忆注入”，从源头控制 Token 使用。

---

### 5.2 Agent 执行阶段的短时记忆管理

* 记录关键中间决策（L1）
* 标记：

  * 复用的历史记忆
  * 新产生的潜在知识

---

## 六、用户反馈与记忆更新机制

### 6.1 用户反馈设计

* 支持简单反馈形式：

  * 👍 / 👎
  * 或 1～5 分
* 可选文本说明原因

---

### 6.2 反馈驱动的记忆更新策略

* 正反馈：

  * 提升相关 L2 记忆的 reward / confidence
* 负反馈：

  * 降低权重
  * 标记为 `needs_revision`

该机制可直接作为：

* 偏好学习
* DPO 正负样本来源

---

### 6.3 短时记忆向长期记忆的提炼

* 从 L1 中抽取：

  * 成功策略
  * 失败原因
* 生成新的 L2 JSON 记忆
* 自动生成或更新对应的 Markdown 反思（L3）

---

## 七、上下文与 Token 控制策略

* 每次调用前计算可用 Token 预算
* 记忆注入优先级：

  1. 明确命中的偏好与约束
  2. 高 reward 的策略记忆
  3. 最近且相关的经验
* 超预算时：

  * 丢弃低权重记忆
  * 使用 Markdown Summary 替代原始内容

---

## 八、可扩展与演进方向

* 记忆冲突检测与合并
* 时间衰减与自动清理
* 多 Agent 记忆共享 / 隔离策略
* 更高级的策略学习（DPO / RL）

---

## 九、总结

> **本记忆系统的核心思想是：**
>
> * 用结构化记忆支撑系统决策与学习
> * 用自然语言记忆服务模型理解与人类协作
> * 通过反馈形成持续演进的智能体行为闭环
